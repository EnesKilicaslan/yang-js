
# -*- mode: yaml; -*-

# YANG Version 1.0 YIN Specification

# This file defines the [RFC 6020](http://www.rfc-editor.org/rfc/rfc6020.txt) 
# compliant language extensions.  It is used by `Yang` to handle
# compatible YANG schema definitions into executable JS code.

# The extensions are handled by utilizing the various specifications
# that define 'scope', 'construct', etc. which provides
# contextual mapping for different types of extension statements to
# produce logical JS object representations.

# Implementing new extensions for YANG language is very
# straight-forward as long as the context for the callback function to
# handle the extension is well understood.  For more details, please
# refer to documentation found inside the main `yang-js` project.

# YANG version 1.0 built-in language extensions
argument: !yang/extension
  argument: arg-type # required
  scope:
    yin-element: 0..1

augment: !yang/extension
  scope:
    anyxml:      0..n
    case:        0..n
    choice:      0..n
    container:   0..n
    description: 0..1
    if-feature:  0..n
    leaf:        0..n
    leaf-list:   0..n
    list:        0..n
    reference:   0..1
    status:      0..1
    uses:        0..n
    when:        0..1

belongs-to: !yang/extension
  scope:
    prefix: 1
  construct: !coffee/function |
    -> @parent[@prefix.arg] = @resolve 'module', @arg

# TODO
bit: !yang/extension
  scope:
    description: 0..1
    reference: 0..1
    status: 0..1
    position: 0..1

# TODO
case: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    uses: 0..n
    when: 0..1

# TODO
choice: !yang/extension
  scope:
    anyxml: 0..n
    case: 0..n
    config: 0..1
    container: 0..n
    default: 0..1
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    mandatory: 0..1
    reference: 0..1
    status: 0..1
    when: 0..1

config: !yang/extension
  construct: !coffee/function |
    -> @arg = (@arg is true or @arg is 'true')

container: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    must: 0..n
    presence: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    when: 0..1
  construct: !coffee/function |
    ->
      @on 'create', (data, element) =>
        return unless data?

        unless data instanceof Object
          throw @error "must supply object data for creating a new container element"

        # validate the 'when' statement
        unless (@when?.test? element) is false
          element.enumerable = true
          unless element.schema?
            #console.warn "assigning data into place-holder container without schema definition"
            element.state = data
          else
            element.merge data
        else
          element.enumerable = false

# TODO
deviate: !yang/extension
  scope:
    config: 0..1
    default: 0..1
    mandatory: 0..1
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    type: 0..1
    unique: 0..1
    units: 0..1

# TODO
deviation: !yang/extension
  scope:
    description: 0..1
    deviate: 1..n
    reference: 0..1

enum: !yang/extension
  scope:
    description: 0..1
    reference: 0..1
    status: 0..1
    value: 0..1
  construct: !coffee/function |
    ->
      @parent.enumValue ?= 0
      unless @value?
        @extend "value #{@parent.enumValue++};"
      else
        cval = (Number @value.arg) + 1
        @parent.enumValue = cval unless @parent.enumValue > cval

extension: !yang/extension
  argument: name # required
  scope: 
    argument: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
  construct: !coffee/function |
    -> 
      source = (@resolve 'extension', @arg)
      # override the resolve function to call the 'source' instead
      @resolve = @resolve.bind source

feature: !yang/extension
  scope:
    description: 0..1
    if-feature: 0..n
    reference: 0..1
    status: 0..1
  construct: !coffee/function |
    ->
      if @status.arg is 'unavailable'
        console.warn "feature #{@arg} is unavailable"
      @on 'create', (data, element) =>
        element.get = -> require element.tag
      #   # if typeof ctx.feature is 'object'
      #   #   delete ctx.feature[arg]
      #   # else
      #   #   delete ctx.feature

grouping: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n

identity: !yang/extension
  scope:
    base: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
  # TODO: resolve 'base' statements
  construct: !coffee/function |
    -> 
      if @base?
        @resolve 'identity', @base.arg

if-feature: !yang/extension
  construct: !coffee/function |
    ->
      unless (@resolve 'feature', @arg)?
        console.warn "should be turned off..."
        #@define 'status', off

import: !yang/extension
  scope:
    prefix: 1
    revision-date: 0..1
  construct: !coffee/function |
    ->
      m = @resolve 'module', @arg
      unless m?
        throw @error "unable to resolve '#{@arg}' module", 'import'

      rev = @['revision-date'].arg
      if rev? and not (rev of m.revision)
        throw @error "requested #{rev} not available in #{@arg}", 'import'

      # should it be preprocessed map of m (just declared meta-data)?
      @parent[@prefix.arg] = m

      # TODO: Should be handled in extension construct
      # go through extensions from imported module and update 'scope'
      for k, v of m.extension ? {}
        for pkey, scope of v.resolve 'parent-scope'
          target = @parent.resolve 'extension', pkey
          target?.scope["#{@prefix.arg}:#{k}"] = scope

include: !yang/extension
  scope:
    argument: module
    revision-date: 0..1
  construct: !coffee/function |
    ->
      m = @resolve 'submodule', @arg
      unless m?
        throw @error "unable to resolve '#{@arg}' submodule", 'include'
      unless (@parent.arg of m['belongs-to'].arg)
        throw @error "requested submodule '#{@arg}' does not belongs-to '#{@parent.arg}'", 'include'
      @parent.extends m.expressions()...

input: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n

leaf: !yang/extension
  scope:
    config: 0..1
    default: 0..1
    description: 0..1
    if-feature: 0..n
    mandatory: 0..1
    must: 0..n
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
  construct: !coffee/function |
    ->
      @on 'create', (data, element) =>
        data ?= @default?.arg
        data = switch
          when not data? and @mandatory?.arg is true
            throw @error "must set value on this leaf #{@arg}"
          when data? and @type?
            @type.convert data if @type?
          else data
        unless (@when?.test? element) is false
          element.enumerable = true
          element.state = data
        else
          element.enumerable = false
          element.state = undefined

leaf-list: !yang/extension
  scope:
    config: 0..1
    description: 0..1
    if-feature: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
  construct: !coffee/function |
    ->
      @on 'create', (data, element) =>
        return unless data?
        override = true if data instanceof Array 
        data = switch
          when not data? then []
          when not @type? and data instanceof Array then data
          when not @type? then [ data ]
          when data instanceof Array then data.map (x) => @type.convert x
          else [ @type.convert data ]

        existingCount = if override then 0 else (element.state?.length ? 0)

        if @['min-elements']?
          unless existingCount + data.length >= @['min-elements'].arg
            throw @error "#{arg} must contain at least #{@['min-elements'].arg} elements"
        if @['max-elements']?
          unless existingCount + data.length <= @['max-elements'].arg
            throw @error "#{arg} must contain at most #{@['max-elements'].arg} elements"

        unless (@when?.test? element) is false
          element.enumerable = true
          if override is true
            element.state = data
          else
            element.state ?= []
            element.state = [].concat element.state, data
        else
          element.enumerable = false
          element.state = undefined
        
list: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    key: 0..1
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    unique: 0..1
    uses: 0..n
    when: 0..1
  construct: !coffee/function |
    ->
      @on 'create', (data, element) =>
        return unless data?
        
        unless element.schema?
          throw @error "cannot create list element without element schema definition"

        data = element.transform data
        

mandatory: !yang/extension
  construct: !coffee/function |
    -> @arg = (@arg is true or @arg is 'true')

max-elements: !yang/extension
  construct: !coffee/function |
    -> @arg = (Number) @arg unless @arg is 'unbounded'

min-elements: !yang/extension
  construct: !coffee/function |
    -> @arg = (Number) @arg

module: !yang/extension
  argument: name # required
  scope:
    anyxml: 0..n
    augment: 0..n
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    namespace: 0..1
    notification: 0..n
    organization: 0..1
    prefix: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
  construct: !coffee/function |
    ->
      #delete ctx[@get('prefix')]
      if @extension?.length > 0
        console.debug? "[module:#{@arg}] found #{@extension.length} new extension(s)"

      @on 'create', (data, element) =>
        return unless data?

        unless element.schema?
          throw @error "cannot create a new module without any schema defined elements"

        unless data instanceof Object
          throw @error "must supply object data for creating a new module element"
        
        # validate the 'when' statement
        unless (@when?.test? element) is false
          element.enumerable = true
          element.merge data
        else
          element.enumerable = false

        # TODO
        # for target, change of @parent.get 'augment'
        #   (@locate target)?.extends change.elements(create:true)...
        # return this

        # for k, v of params.import
        #   modules[k] = @resolve k
        # (synth.Store params, -> @set name: arg, modules: modules).bind children

# TODO
must: !yang/extension
  scope:
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1

# TODO
notification: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
  construct: !coffee/function |
    -> 

output: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
  construct: !coffee/function |
    ->
      synth = @resolve 'synthesizer'
      (synth.Object params).bind children

path: !yang/extension
  construct: !coffee/function |
    -> @arg = @arg?.replace /[_]/g, '.'

pattern: !yang/extension
  construct: !coffee/function |
    -> @arg = new RegExp @arg

prefix: !yang/extension
  construct: !coffee/function |
    -> @parent[@arg] = @parent

refine: !yang/extension
  scope:
    default: 0..1
    description: 0..1
    reference: 0..1
    config: 0..1
    mandatory: 0..1
    presence: 0..1
    must: 0..n
    min-elements: 0..1
    max-elements: 0..1
    units: 0..1

require-instance: !yang/extension
  construct: !coffee/function |
    -> @arg = (@arg is true or @arg is 'true')

revision: !yang/extension
  scope:
    description: 0..1
    reference: 0..1

rpc: !yang/extension
  scope:
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    input: 0..1
    output: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
  construct: !coffee/function |
    ->
      @element = true
      @on 'create', (func, element) =>
        unless func instanceof Function
          console.warn "cannot set rpc without specifying function"
          return
        unless func.length is 3
          console.warn "cannot set rpc without function (input, resolve, reject)"
          return

        rpc = @create()
        element.state = (input, resolve, reject) -> 
          rpc.input = input
          func.apply this, [
            rpc.input
            (res) -> rpc.output = res; resolve rpc.output
            (err) -> reject err
          ]

submodule: !yang/extension
  scope:
    anyxml: 0..n
    augment: 0..n
    belongs-to: 0..1
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    notification: 0..n
    organization: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
  construct: !coffee/function |
    ->
      # ctx.set 'submodule', @arg, this
      # ctx[k] = v for k, v of params
      # delete ctx.submodule

status: !yang/extension
  construct: !coffee/function |
    -> @arg = @arg ? 'current'

type: !yang/extension
  scope:
    base: 0..1
    bit: 0..n
    enum: 0..n
    fraction-digits: 0..1
    length: 0..1
    path: 0..1
    pattern: 0..n
    range: 0..1
    require-instance: 0..1
    type: 0..n # for 'union' case only
  construct: !coffee/function |
    (obj) ->
      delete @enumValue
      exists = @resolve 'typedef', @arg
      unless exists?
        throw @error "unable to resolve typedef for #{@arg}"

      @convert = exists.convert.bind null, this

      # TODO: deal with typedef overrides
      # @parent.once 'created', (yang) ->
      #   yang.extends exists.expressions('default','units','type')...

typedef: !yang/extension
  scope:
    default: 0..1
    description: 0..1
    units: 0..1
    type: 0..1
    reference: 0..1
  construct: !coffee/function |
    -> 
      if @type?
        @convert = @type.convert
        return

      builtin = @resolve 'typedef', @arg
      unless builtin?.convert instanceof Function
        throw @error "unable to resolve '#{@arg}' built-in type"
      @convert = (schema..., value) ->
        schema = schema.reduce ((a, b) ->
          a[k] = v for own k, v of b; a
        ), {}
        builtin.convert.call schema, value
      
uses: !yang/extension
  scope:
    augment: 0..n
    description: 0..1
    if-feature: 0..n
    refine: 0..n
    reference: 0..1
    status: 0..1
    when: 0..1
  construct: !coffee/function |
    ->
      grouping = (@resolve 'grouping', @arg)
      unless grouping?
        throw @error "unable to use #{@arg} grouping definition", this

      uses = grouping.create()
      # @augment.forEach (x) => x.transform {}, uses
      # @refine.forEach (x) => x.transform {}, uses

      @parent.on 'create', (data, element) =>
        unless (@when?.test? element) is false
          element.extend uses

when: !yang/extension
  scope:
    description: 0..1
    reference: 0..1

yin-element: !yang/extension
  argument: value # required


# Special non RFC-6020 extensions

composition: !yang/extension
  argument: name
  scope:
    description: 0..1
    composition: 0..n
    contact: 0..1
    module: 0..n
    namespace: 0..1
    notification: 0..n
    organization: 0..1
    reference: 0..1
    rpc: 0..n

###########################################################################
# YANG version 1.0 built-in TYPEDEFs
###########################################################################

binary: !yang/typedef
  convert: !coffee/function |
    (value) ->
      unless value instanceof Function
        throw new Error "value not a binary instance"
      value

boolean: !yang/typedef
  convert: !coffee/function |
    (value) -> 
      if typeof value is 'string' 
        unless value in [ 'true', 'false' ]
          throw new Error "boolean value must be 'true' or 'false'"
        value is 'true'
      else
        Boolean value

decimal64: !yang/typedef
  convert: !coffee/function |
    (value) -> 
      if Number.isNaN (Number value)
        throw new Error "#{@arg} unable to convert '#{value}'"
      Number value

empty: !yang/typedef
  convert: !coffee/function |
    (value) -> null

enumeration: !yang/typedef
  convert: !coffee/function |
    (value) ->
      unless @enum?.length > 0
        trhow new Error "#{@arg} enumeration must have one or more 'enum' definitions"
      for i in @enum
        return i.arg if value is i.arg
        return i.arg if value is i.value.arg
        return i.arg if "#{value}" is i.value.arg
      throw new Error "#{@arg} enumeration type violation for '#{value}' on #{@enum.map (x) -> x.arg}"

identityref: !yang/typedef
  convert: !coffee/function |
    (params={}, source) ->
      unless typeof params.base is 'string'
        throw source.error "identityref must reference 'base' identity"

      (value) ->
        match = source.resolve 'identity', value
        unless (match? and params.base is match.base)
          throw source.error "[#{@opts.type}] identityref is invalid for '#{value}'"
        # TODO - need to figure out how to return namespace value...
        value

instance-identifier: !yang/typedef
  convert: !coffee/function |
    (params={}, source) ->

leafref: !yang/typedef
  convert: !coffee/function |
    (params={}, source) ->
      unless typeof params.path is 'string'
        throw source.error "leafref must contain 'path' statement"

      (value) ->
        self = this
        value: value
        path: params.path
        validate: -> true
        get: ->
          ref = source.locate self, @path
          match = switch
            when ref instanceof Array then @value in ref
            else @value is ref
          if match is true
            @value
          else
            'error-tag': 'data-missing'
            'error-app-tag': 'instance-required'
            'error-path': @path

number: !yang/typedef
  convert: !coffee/function |
    (value) ->
      if Number.isNaN (Number value)
        throw new Error "#{@arg} expects '#{value}' to a number"
      if @range?
        ranges = @range.arg.split '|'
        ranges = ranges.map (e) ->
          [ min, max ] = e.split '..'
          if max is 'max'
            console.warn "max keyword on range not yet supported"
          min = (Number) min
          max = (Number) max
          (v) -> (not min? or v >= min) and (not max? or v <= max)
      value = Number value
      unless (not ranges? or ranges.some (test) -> test? value)
        throw new Error "#{@arg} range violation for '#{value}' on #{params.range}"
      value

string: !yang/typedef
  convert: !coffee/function |
    (value) ->
      patterns = @pattern?.map (x) -> x.arg
      if @length?
        ranges = @length.arg.split '|'
        ranges = ranges.map (e) ->
          [ min, max ] = e.split '..'
          min = (Number) min
          max = switch
            when max is 'max' then null
            else (Number) max
          (v) -> (not min? or v.length >= min) and (not max? or v.length <= max)

      value = String value
      unless (not ranges? or ranges.some (test) -> test? value)
        throw new Error "#{@arg} length violation for '#{value}' on #{@length}"
      unless (not patterns? or patterns.every (regex) -> regex.test value)
        throw new Error "#{@arg} pattern violation for '#{value}'"
      value

union: !yang/typedef
  convert: !coffee/function  |
    (params={}, source, callee) ->
      types = (for key, value of params.type
        result = {}
        callee.call source, key, value, null, result
        result.type
      ).filter (e) -> e?
      (value) ->
        for type in types
          try return type value
          catch then continue
        throw new Error "[#{@opts.type}] unable to find matching type for '#{value}' within: #{types}"
