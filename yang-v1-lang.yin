# -*- mode: yaml; -*-

# YANG Version 1.0 YIN Specification

# This file defines the [RFC 6020](http://www.rfc-editor.org/rfc/rfc6020.txt) 
# compliant language extensions.  It is used by `Yang` to handle
# compatible YANG schema definitions into executable JS code.

# The extensions are handled by utilizing the various specifications
# that define 'scope', 'transform', 'element', etc. which provides
# contextual mapping for different types of extension statements to
# produce logical JS object representations.

# Implementing new extensions for YANG language is very
# straight-forward as long as the context for the callback function to
# handle the extension is well understood.  For more details, please
# refer to documentation found inside the main `yang-js` project.

# YANG version 1.0 built-in language extensions
argument: !yang/extension
  argument: arg-type # required
  scope:
    yin-element: 0..1

augment: !yang/extension
  scope:
    anyxml:      0..n
    case:        0..n
    choice:      0..n
    container:   0..n
    description: 0..1
    if-feature:  0..n
    leaf:        0..n
    leaf-list:   0..n
    list:        0..n
    reference:   0..1
    status:      0..1
    uses:        0..n
    when:        0..1

belongs-to: !yang/extension
  scope:
    prefix: 1
  transform: !coffee/function |
    (params) -> @parent[params.prefix] = @resolve 'module', @arg

# TODO
bit: !yang/extension
  scope:
    description: 0..1
    reference: 0..1
    status: 0..1
    position: 0..1

# TODO
case: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    uses: 0..n
    when: 0..1

# TODO
choice: !yang/extension
  scope:
    anyxml: 0..n
    case: 0..n
    config: 0..1
    container: 0..n
    default: 0..1
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    mandatory: 0..1
    reference: 0..1
    status: 0..1
    when: 0..1

config: !yang/extension
  transform: !coffee/function |
    (params) -> @arg = (@arg is true or @arg is 'true')

container: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    must: 0..n
    presence: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    when: 0..1
  element:
    enumerable: true

# TODO
deviate: !yang/extension
  scope:
    config: 0..1
    default: 0..1
    mandatory: 0..1
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    type: 0..1
    unique: 0..1
    units: 0..1

# TODO
deviation: !yang/extension
  scope:
    description: 0..1
    deviate: 1..n
    reference: 0..1

enum: !yang/extension
  scope:
    description: 0..1
    reference: 0..1
    status: 0..1
    value: 0..1
  transform: !coffee/function |
    (params) ->
      value = params.value
      unless value?
        @parent.enumValue ?= 0
        @merge "value #{@parent.enumValue++};"
      else
        @parent.enumValue = (Number) value.arg + 1

extension: !yang/extension
  argument: name # required
  scope: 
    argument: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
  transform: !coffee/function |
    (params) -> @parent = (@resolve 'extension', @arg)

feature: !yang/extension
  scope:
    description: 0..1
    if-feature: 0..n
    reference: 0..1
    status: 0..1
  transform: !coffee/function |
    (params) ->
      # if @get('status') is 'unavailable'
      #   console.warn "feature #{@arg} is unavailable"
      #   # if typeof ctx.feature is 'object'
      #   #   delete ctx.feature[arg]
      #   # else
      #   #   delete ctx.feature
  transform2: !coffee/function |
    (arg, params, children) ->
      feature = @resolve 'feature', arg, module: @name
      null

grouping: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n

identity: !yang/extension
  scope:
    base: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
  # TODO: resolve 'base' statements
  transform: !coffee/function |
    (params) -> 
      if params.base?
        @resolve 'identity', params.base

if-feature: !yang/extension
  transform: !coffee/function |
    (params) ->
      unless (@resolve 'feature', @arg, module: @name)?
        @define 'status', off

import: !yang/extension
  scope:
    prefix: 1
    revision-date: 0..1
  transform: !coffee/function |
    (params) ->
      m = @resolve 'module', @arg
      unless m?
        throw @error "unable to resolve '#{@arg}' module", 'import'

      rev = params['revision-date']
      if rev? and not (rev of m.resolve 'revision')
        throw @error "requested #{rev} not available in #{@arg}", 'import'

      # should it be preprocessed map of m (just declared meta-data)?
      @parent[params.prefix] = m

      # go through extensions from imported module and update 'scope'
      for k, v of (m.resolve 'extension') when v instanceof @constructor
        for pkey, scope of v.resolve 'parent-scope'
          target = @parent.resolve 'extension', pkey
          target?.define 'scope', "#{params.prefix}:#{k}", scope

include: !yang/extension
  scope:
    argument: module
    revision-date: 0..1
  transform: !coffee/function |
    (params) ->
      m = @resolve 'submodule', @arg
      unless m?
        throw @error "unable to resolve '#{@arg}' submodule", 'include'
      unless (@parent.arg of m.resolve 'belongs-to')
        throw @error "requested '#{@arg}' is not belongs-to '#{@parent.arg}'", 'include'
      @parent.merge m.expressions()...

input: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
  element:
    enumerable: false

leaf: !yang/extension
  scope:
    config: 0..1
    default: 0..1
    description: 0..1
    if-feature: 0..n
    mandatory: 0..1
    must: 0..n
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
  element:
    enumerable: true
    set: !coffee/function |
      (value) -> 
        meta = @__meta__
        if not value? and meta.mandatory is true
          console.warn "must set value on this leaf"
          return
        @_ = (@type? value) ? value
        # switch @type
        #   when 'instance-identifier'
        #     #synth.BelongsTo params, -> @set model: children.type
        #   else
        #     #synth.Property params, -> @set type: children.type if children.type?
        return this

leaf-list: !yang/extension
  scope:
    config: 0..1
    description: 0..1
    if-feature: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
  transform2: !coffee/function |
    (arg, params, children) ->
      synth = @resolve 'synthesizer'
      if params.type?['instance-identifier']?
        synth.HasMany params, -> @set model: children.type
      else
        synth.List params, -> @set type: children.type if children.type?
  represent: !coffee/function |
    (arg, obj, opts) ->
      params = obj?.extract?() ? obj
      "leaf-list #{arg} {#{@dump params, opts}}"

list: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    key: 0..1
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    unique: 0..1
    uses: 0..n
    when: 0..1
  transform2: !coffee/function |
    (arg, params, children) ->
      synth = @resolve 'synthesizer'
      item = (synth.Object null).bind children
      (synth.List params).set type: item
  represent: !coffee/function |
    (arg, obj, opts) ->
      params = obj?.extract?() ? obj
      "list #{arg} {#{@dump params, opts}}"

mandatory: !yang/extension
  transform: !coffee/function |
    (params) -> @arg = (@arg is true or @arg is 'true')

max-elements: !yang/extension
  transform: !coffee/function |
    (params) -> @arg = (Number) @arg unless @arg is 'unbounded'

min-elements: !yang/extension
  transform: !coffee/function |
    (params) -> @arg = (Number) @arg

module: !yang/extension
  argument: name # required
  scope:
    anyxml: 0..n
    augment: 0..n
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    namespace: 0..1
    notification: 0..n
    organization: 0..1
    prefix: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
  element: 
    enumerable: true
  transform: !coffee/function |
    (params) ->
      #delete ctx[@get('prefix')]

  transform2: !coffee/function |
    (children) ->
      @merge children...
      for target, change of @parent.get 'augment'
        (@locate target)?.merge change.elements(create:true)...
      return this

      for k, v of params.import
        modules[k] = @resolve k
      (synth.Store params, -> @set name: arg, modules: modules).bind children

# TODO
must: !yang/extension
  scope:
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1

# TODO
notification: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
  transform: !coffee/function |
    (params) -> 

output: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
  element:
    enumerable: false
  transform: !coffee/function |
    (arg, params, children) ->
      synth = @resolve 'synthesizer'
      (synth.Object params).bind children

path: !yang/extension
  transform: !coffee/function |
    (params) -> @arg = @arg?.replace /[_]/g, '.'

pattern: !yang/extension
  transform: !coffee/function |
    (params) ->
      @parent.patterns ?= []
      @parent.patterns.push new RegExp @arg

prefix: !yang/extension
  transform: !coffee/function |
    (params) -> @parent[@arg] = @parent.map

refine: !yang/extension
  scope:
    default: 0..1
    description: 0..1
    reference: 0..1
    config: 0..1
    mandatory: 0..1
    presence: 0..1
    must: 0..n
    min-elements: 0..1
    max-elements: 0..1
    units: 0..1

require-instance: !yang/extension
  transform: !coffee/function |
    (params) -> @arg = (@arg is true or @arg is 'true')

revision: !yang/extension
  scope:
    description: 0..1
    reference: 0..1

rpc: !yang/extension
  scope:
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    input: 0..1
    output: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
  element:
    enumerable: false
    invocable: true
    get: !coffee/function |
      ->
        rpc = this
        rpc.method ?= (input, resolve, reject) ->
          reject "No control logic defined for requested rpc operation"
        (input, resolve, reject) -> 
          rpc.input = input
          rpc.method.apply this, [
            rpc.input
            (res) -> rpc.output = res; resolve rpc.output
            (err) -> reject err
          ]
    set: !coffee/function |
      (func) ->
        unless func instanceof Function
          console.warn "cannot set rpc without specifying function"
          return
        unless func.length is 3
          console.warn "cannot set rpc without function (input, resolve, reject)"
          return
        @method = func
        return this

submodule: !yang/extension
  scope:
    anyxml: 0..n
    augment: 0..n
    belongs-to: 0..1
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    notification: 0..n
    organization: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
  transform: !coffee/function |
    (params) ->
      # ctx.set 'submodule', @arg, this
      # ctx[k] = v for k, v of params
      # delete ctx.submodule

status: !yang/extension
  transform: !coffee/function |
    (params) -> @arg ?= @arg

type: !yang/extension
  scope:
    base: 0..1
    bit: 0..n
    enum: 0..n
    fraction-digits: 0..1
    length: 0..1
    path: 0..1
    pattern: 0..n
    range: 0..1
    require-instance: 0..1
    type: 0..n # for 'union' case only
  element:
    # define this as an immutable element
    enumerable: false
    writable: false
    key: type
    value: !coffee/function |
      (value) -> @convert value

        console.log 'performing YANG type validations on passed-in value'

        return @convert value

        # dynamically transform the type according to YANG schema
        type = @resolve 'typedef', @arg
        unless type?
          throw @error "unable to resolve typedef for #{@arg}"

        switch
          # handle built-in typedefs with transform
          when typedef.transform?
            ctx.type = typedef.transform params, this, arguments.callee

          when typeof typedef.type is 'object'
            for key, value of typedef.type
              mparams = @copy {}, value
              @copy mparams, params
              arguments.callee.call this, key, mparams, children, ctx

          when typeof typedef.type is 'string'
            arguments.callee.call this, typedef.type, params, children, ctx

        ctx.type?.toString = -> arg
        null
        console.log this
        this
  transform: !coffee/function |
    (params) ->
      delete @enumValue
      exists = @resolve 'typedef', @arg
      unless exists?
        throw @error "unable to resolve typedef for #{@arg}"

      # the below merge would set the type before this current type is processed
      @parent.once 'created', (yang) ->
        yang.merge exists.expressions('default','units','type')...

      @convert = (exists.convert).bind ([].concat exists.expressions(), @expressions())
      @convert = (-> exists.convert.apply this, arguments).bind @expressions()

typedef: !yang/extension
  scope:
    default: 0..1
    description: 0..1
    units: 0..1
    type: 0..1
    reference: 0..1
  transform: !coffee/function |
    (params) -> 
      builtin = @resolve @arg
      
  # built-in typedefs
  binary: !coffee/function |
    (params, source) -> (value) ->
      unless value instanceof Function
        throw source.error "[#{@opts.type}] not a binary instance"
      value

  boolean: !coffee/function |
    (params) ->
      (value) ->
        switch
          when typeof value is 'string' then value is 'true'
          else Boolean value

  decimal64: !coffee/function |
    (params) -> (value) -> value

  empty: !coffee/function |
    (params) -> 'empty'

  enumeration: !coffee/function |
    (params={}, source) ->
      unless params.enum instanceof Object
        name = params.enum
        params.enum = {}
        params.enum[name] = value: 0
      f = (value) ->
        if typeof value is 'number'
          for key, val of params.enum when val.value is value or val.value is "#{value}"
            return key
        unless (params.enum.hasOwnProperty value)
          throw source.error "[#{@opts.type}] enumeration type violation for '#{value}' on #{Object.keys params.enum}"
        value
      f.enum = params.enum
      return f

  identityref: !coffee/function |
    (params={}, source) ->
      unless typeof params.base is 'string'
        throw source.error "identityref must reference 'base' identity"

      (value) ->
        match = source.resolve 'identity', value
        unless (match? and params.base is match.base)
          throw source.error "[#{@opts.type}] identityref is invalid for '#{value}'"
        # TODO - need to figure out how to return namespace value...
        value

  instance-identifier: !coffee/function |
    (params={}, source) ->

  leafref: !coffee/function |
    (params={}, source) ->
      unless typeof params.path is 'string'
        throw source.error "leafref must contain 'path' statement"

      (value) ->
        self = this
        value: value
        path: params.path
        validate: -> true
        get: ->
          ref = source.locate self, @path
          match = switch
            when ref instanceof Array then @value in ref
            else @value is ref
          if match is true
            @value
          else
            'error-tag': 'data-missing'
            'error-app-tag': 'instance-required'
            'error-path': @path

  number: !coffee/function |
    (params={}, source) ->
      if params.range?
        ranges = params.range.split '|'
        ranges = ranges.map (e) ->
          [ min, max ] = e.split '..'
          if max is 'max'
            console.warn "max keyword on range not yet supported"
          min = (Number) min
          max = (Number) max
          (v) -> (not min? or v >= min) and (not max? or v <= max)
      (value) ->
        value = (Number) value
        unless (not ranges? or ranges.some (test) -> test? value)
          throw source.error "[#{@opts.type}] range violation for '#{value}' on #{params.range}"
        value

  string: !coffee/function |
    (value) ->
      patterns = []
      if params.pattern instanceof Object
        patterns.push (new RegExp regex) for regex of params.pattern
      else
        patterns.push (new RegExp params.pattern) if params.pattern?

      if params.length?
        ranges = params.length.split '|'
        ranges = ranges.map (e) ->
          [ min, max ] = e.split '..'
          min = (Number) min
          max = switch
            when max is 'max' then null
            else (Number) max
          (v) -> (not min? or v.length >= min) and (not max? or v.length <= max)
      value = String value
      unless (not ranges? or ranges.some (test) -> test? value)
        throw source.error "[#{@opts.type}] length violation for '#{value}' on #{params.length}"
      unless (not patterns? or patterns.every (regex) -> regex.test value)
        throw source.error "[#{@opts.type}] pattern violation for '#{value}'"
      value

  union: !coffee/function  |
    (params={}, source, callee) ->
      types = (for key, value of params.type
        result = {}
        callee.call source, key, value, null, result
        result.type
      ).filter (e) -> e?
      (value) ->
        for type in types
          try return type value
          catch then continue
        throw new Error "[#{@opts.type}] unable to find matching type for '#{value}' within: #{types}"

uses: !yang/extension
  scope:
    augment: 0..n
    description: 0..1
    if-feature: 0..n
    refine: 0..n
    reference: 0..1
    status: 0..1
    when: 0..1
  transform: !coffee/function |
    ->
      unless (@resolve 'grouping', @arg)?
        throw @error "unable to use #{@arg} grouping definition", this
      @parent.on 'transform', (exprs...) ->
        

  transform2: !coffee/function |
    (children) ->
      # grab grouping elements from schema
      @merge (@parent.resolve 'grouping', @parent.arg).elements(create:true)...
      for target, change of @parent.get 'refine'
        (@locate target)?.merge change.elements(create:true)..., true
      for target, change of @parent.get 'augment'
        (@locate target)?.merge change.elements(create:true)...
      return @elements()

when: !yang/extension
  scope:
    description: 0..1
    reference: 0..1

yin-element: !yang/extension
  argument: value # required


# typedef test1 {
#   default a;
#   type string {
#     length 1;
#   }
# }

# typedef test2 {
#   default b;
#   type test1;
# }

# leaf foo { 
#   type test2; 
#   default c;
# }

# leaf bar {
#   type union {
#     type string;
#     type int32;
#   }
# }
