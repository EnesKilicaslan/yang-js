
# -*- mode: yaml; -*-

# YANG Version 1.0 YIN Specification

# This file defines the [RFC 6020](http://www.rfc-editor.org/rfc/rfc6020.txt) 
# compliant language extensions.  It is used by `Yang` to handle
# compatible YANG schema definitions into executable JS code.

# The extensions are handled by utilizing the various specifications
# that define 'scope', 'construct', etc. which provides
# contextual mapping for different types of extension statements to
# produce logical JS object representations.

# Implementing new extensions for YANG language is very
# straight-forward as long as the context for the callback function to
# handle the extension is well understood.  For more details, please
# refer to documentation found inside the main `yang-js` project.

# YANG version 1.0 built-in language extensions
argument: !yang/extension
  argument: arg-type # required
  scope:
    yin-element: 0..1

augment: !yang/extension
  scope:
    anyxml:      0..n
    case:        0..n
    choice:      0..n
    container:   0..n
    description: 0..1
    if-feature:  0..n
    leaf:        0..n
    leaf-list:   0..n
    list:        0..n
    reference:   0..1
    status:      0..1
    uses:        0..n
    when:        0..1

belongs-to: !yang/extension
  scope:
    prefix: 1
  resolve: !coffee/function |
    (expr) -> @parent[@prefix.arg] = @lookup 'module', @arg

# TODO
bit: !yang/extension
  scope:
    description: 0..1
    reference: 0..1
    status: 0..1
    position: 0..1

# TODO
case: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    uses: 0..n
    when: 0..1

# TODO
choice: !yang/extension
  scope:
    anyxml: 0..n
    case: 0..n
    config: 0..1
    container: 0..n
    default: 0..1
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    mandatory: 0..1
    reference: 0..1
    status: 0..1
    when: 0..1

config: !yang/extension
  resolve: !coffee/function |
    -> @arg = (@arg is true or @arg is 'true')

container: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    must: 0..n
    presence: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    when: 0..1
  construct: !coffee/function |
    (data) -> 
      return data unless data instanceof Object
      obj = data[@arg] ? {}
      unless obj instanceof Object
        throw @error "container expects an object but got a '#{typeof obj}'"
      obj = expr obj for expr in @expressions
      @update data, @arg, obj
  predicate: !coffee/function |
    (data) -> data instanceof Object

default: !yang/extension
  construct: !coffee/function |
    (data) -> data ? @arg

# TODO
deviate: !yang/extension
  scope:
    config: 0..1
    default: 0..1
    mandatory: 0..1
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    type: 0..1
    unique: 0..1
    units: 0..1

# TODO
deviation: !yang/extension
  scope:
    description: 0..1
    deviate: 1..n
    reference: 0..1

enum: !yang/extension
  scope:
    description: 0..1
    reference: 0..1
    status: 0..1
    value: 0..1
  resolve: !coffee/function |
    (expr) -> 
      @parent.enumValue ?= 0
      unless @value?
        @extends "value #{@parent.enumValue++};"
      else
        cval = (Number @value.arg) + 1
        @parent.enumValue = cval unless @parent.enumValue > cval

extension: !yang/extension
  argument: name # required
  scope: 
    argument: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
  resolve: !coffee/function |
    (expr) -> @origin = (@lookup 'extension', @arg) ? {}

feature: !yang/extension
  scope:
    description: 0..1
    if-feature: 0..n
    reference: 0..1
    status: 0..1
  resolve: !coffee/function |
    (expr) ->
      if @status.arg is 'unavailable'
        console.warn "feature #{@arg} is unavailable"
      @on 'create', (element) =>
        element.state = require element.kw
      #   # if typeof ctx.feature is 'object'
      #   #   delete ctx.feature[arg]
      #   # else
      #   #   delete ctx.feature

grouping: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n

identity: !yang/extension
  scope:
    base: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
  # TODO: resolve 'base' statements
  resolve: !coffee/function |
    (expr) -> 
      if @base?
        @lookup 'identity', @base.arg

if-feature: !yang/extension
  resolve: !coffee/function |
    (expr) ->
      unless (@lookup 'feature', @arg)?
        console.warn "should be turned off..."
        #@define 'status', off

import: !yang/extension
  scope:
    prefix: 1
    revision-date: 0..1
  resolve: !coffee/function |
    (expr) ->
      m = @lookup 'module', @arg
      unless m?
        throw @error "unable to resolve '#{@arg}' module", 'import'

      rev = @['revision-date'].arg
      if rev? and not (rev of m.revision)
        throw @error "requested #{rev} not available in #{@arg}", 'import'

      # should it be preprocessed map of m (just declared meta-data)?
      @parent[@prefix.arg] = m

      # TODO: Should be handled in extension construct
      # go through extensions from imported module and update 'scope'
      for k, v of m.extension ? {}
        for pkey, scope of v.resolve 'parent-scope'
          target = @parent.resolve 'extension', pkey
          target?.scope["#{@prefix.arg}:#{k}"] = scope

include: !yang/extension
  scope:
    argument: module
    revision-date: 0..1
  resolve: !coffee/function |
    (expr) ->
      m = @lookup 'submodule', @arg
      unless m?
        throw @error "unable to resolve '#{@arg}' submodule", 'include'
      unless (@parent.arg of m['belongs-to'].arg)
        throw @error "requested submodule '#{@arg}' does not belongs-to '#{@parent.arg}'", 'include'
      @parent.extends m.expressions...

input: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n

leaf: !yang/extension
  scope:
    config: 0..1
    default: 0..1
    description: 0..1
    if-feature: 0..n
    mandatory: 0..1
    must: 0..n
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
  construct: !coffee/function |
    (data) ->
      return data unless data instanceof Object
      val = data[@arg]
      console.debug? "expr on leaf #{@arg} for #{val} with #{@expressions.length} exprs"
      val = expr val for expr in @expressions
      @update data, @arg, val

leaf-list: !yang/extension
  scope:
    config: 0..1
    description: 0..1
    if-feature: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
  construct: !coffee/function |
    (data) ->
      return data unless data instanceof Object
      ll = data[@arg] ? []
      ll = expr ll for expr in @expressions
      @update data, @arg, ll

length: !yang/extension
  scope:
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1
        
list: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    key: 0..1
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    unique: 0..1
    uses: 0..n
    when: 0..1
  construct: !coffee/function |
    (data) ->
      return data unless data instanceof Object
      list = data[@arg] ? []
      list = list.map (li) =>
        li = expr li for expr in @expressions
        key = 'xxx'
        @update {}, key, li 
      list = expr list for expr in @expressions
      @update data, @arg, list

mandatory: !yang/extension
  resolve: !coffee/function |
    (expr) -> @arg = (@arg is true or @arg is 'true')
  predicate: !coffee/function |
    (data) -> @arg isnt true or data?

max-elements: !yang/extension
  resolve: !coffee/function |
    (expr) -> @arg = (Number) @arg unless @arg is 'unbounded'
  predicate: !coffee/function |
    (data) -> @arg is 'unbounded' or data not instanceof Array or data.length <= @arg

min-elements: !yang/extension
  resolve: !coffee/function |
    (expr) -> @arg = (Number) @arg
  predicate: !coffee/function |
    (data) -> data not instanceof Array or data.length >= @arg 

module: !yang/extension
  argument: name # required
  scope:
    anyxml: 0..n
    augment: 0..n
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    namespace: 0..1
    notification: 0..n
    organization: 0..1
    prefix: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
  resolve: !coffee/function |
    (expr) ->
      #delete ctx[@get('prefix')]
      if @extension?.length > 0
        console.debug? "[module:#{@arg}] found #{@extension.length} new extension(s)"
    
  construct: !coffee/function |
    (data) ->
      return data unless data instanceof Object
      v = data[@arg] ? {}
      v = expr v for expr in @expressions
      unless v is null
        Object.defineProperty data, @arg, value: v
      
      # TODO
      # for target, change of @parent.get 'augment'
      #   (@locate target)?.extends change.elements(create:true)...
      # return this

      # for k, v of params.import
      #   modules[k] = @lookup k
      # (synth.Store params, -> @set name: arg, modules: modules).bind children

# TODO
must: !yang/extension
  scope:
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1

# TODO
notification: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
  construct: !coffee/function |
    -> 

output: !yang/extension
  scope:
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
  resolve: !coffee/function |
    ->
      synth = @lookup 'synthesizer'
      (synth.Object params).bind children

path: !yang/extension
  resolve: !coffee/function |
    -> @arg = @arg?.replace /[_]/g, '.'

pattern: !yang/extension
  scope:
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1
  resolve: !coffee/function |
    -> @arg = new RegExp @arg

prefix: !yang/extension
  resolve: !coffee/function |
    -> @parent[@arg] = @parent

range: !yang/extension
  scope:
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1

refine: !yang/extension
  scope:
    default: 0..1
    description: 0..1
    reference: 0..1
    config: 0..1
    mandatory: 0..1
    presence: 0..1
    must: 0..n
    min-elements: 0..1
    max-elements: 0..1
    units: 0..1

require-instance: !yang/extension
  resolve: !coffee/function |
    -> @arg = (@arg is true or @arg is 'true')

revision: !yang/extension
  scope:
    description: 0..1
    reference: 0..1

rpc: !yang/extension
  scope:
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    input: 0..1
    output: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
  construct: !coffee/function |
    ->
      @on 'create', (element) =>
        element.on 'set', (func) =>
          unless func instanceof Function
            console.warn "cannot set rpc without specifying function"
            return
          unless func.length is 3
            console.warn "cannot set rpc without function (input, resolve, reject)"
            return

          rpc = @create()
          element.state = (input, resolve, reject) -> 
            rpc.input = input
            func.apply this, [
              rpc.input
              (res) -> rpc.output = res; resolve rpc.output
              (err) -> reject err
            ]

submodule: !yang/extension
  scope:
    anyxml: 0..n
    augment: 0..n
    belongs-to: 0..1
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    notification: 0..n
    organization: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
  resolve: !coffee/function |
    ->
      # ctx.set 'submodule', @arg, this
      # ctx[k] = v for k, v of params
      # delete ctx.submodule

status: !yang/extension
  resolve: !coffee/function |
    -> @arg = @arg ? 'current'

type: !yang/extension
  scope:
    base: 0..1
    bit: 0..n
    enum: 0..n
    fraction-digits: 0..1
    length: 0..1
    path: 0..1
    pattern: 0..n
    range: 0..1
    require-instance: 0..1
    type: 0..n # for 'union' case only
  resolve: !coffee/function |
    (obj) ->
      delete @enumValue
      exists = @lookup 'typedef', @arg
      unless exists?
        throw @error "unable to resolve typedef for #{@arg}"
      @convert = exists.convert.bind null, this
      # TODO: deal with typedef overrides
      # @parent.once 'created', (yang) ->
      #   yang.extends exists.expressions('default','units','type')...
  construct: !coffee/function |
    (data) -> switch
      when not data? then data
      when data instanceof Array then data.map (x) => @convert x
      else @convert data

typedef: !yang/extension
  scope:
    default: 0..1
    description: 0..1
    units: 0..1
    type: 0..1
    reference: 0..1
  resolve: !coffee/function |
    (expr) -> 
      if @type?
        @convert = @type.convert
        return
      builtin = @lookup 'typedef', @arg
      unless builtin?.construct instanceof Function
        throw @error "unable to resolve '#{@arg}' built-in type"
      @convert = (schema..., value) ->
        schema = schema.reduce ((a, b) ->
          a[k] = v for own k, v of b; a
        ), {}
        builtin.construct.call schema, value
      
uses: !yang/extension
  scope:
    augment: 0..n
    description: 0..1
    if-feature: 0..n
    refine: 0..n
    reference: 0..1
    status: 0..1
    when: 0..1
  construct: !coffee/function |
    ->
      grouping = (@lookup 'grouping', @arg)
      unless grouping?
        throw @error "unable to use #{@arg} grouping definition", this

      @on 'transform', (target) =>
        unless (@when?.test? target) is false
          grouping.transform target
          # @augment.forEach (x) => x.transform {}, uses
          # @refine.forEach (x) => x.transform {}, uses

when: !yang/extension
  scope:
    description: 0..1
    reference: 0..1

yin-element: !yang/extension
  argument: value # required


# Special non RFC-6020 extensions

composition: !yang/extension
  argument: name
  scope:
    description: 0..1
    composition: 0..n
    contact: 0..1
    module: 0..n
    namespace: 0..1
    notification: 0..n
    organization: 0..1
    reference: 0..1
    rpc: 0..n

###########################################################################
# YANG version 1.0 built-in TYPEDEFs
###########################################################################

binary: !yang/typedef
  construct: !coffee/function |
    (value) ->
      unless value instanceof Function
        throw new Error "value not a binary instance"
      value

boolean: !yang/typedef
  construct: !coffee/function |
    (value) -> 
      if typeof value is 'string' 
        unless value in [ 'true', 'false' ]
          throw new Error "boolean value must be 'true' or 'false'"
        value is 'true'
      else
        Boolean value

decimal64: !yang/typedef
  construct: !coffee/function |
    (value) -> 
      if Number.isNaN (Number value)
        throw new Error "#{@arg} unable to construct '#{value}'"
      Number value

empty: !yang/typedef
  construct: !coffee/function |
    (value) -> null

enumeration: !yang/typedef
  construct: !coffee/function |
    (value) ->
      unless @enum?.length > 0
        trhow new Error "#{@arg} enumeration must have one or more 'enum' definitions"
      for i in @enum
        return i.arg if value is i.arg
        return i.arg if value is i.value.arg
        return i.arg if "#{value}" is i.value.arg
      throw new Error "#{@arg} enumeration type violation for '#{value}' on #{@enum.map (x) -> x.arg}"

identityref: !yang/typedef
  construct: !coffee/function |
    (params={}, source) ->
      unless typeof params.base is 'string'
        throw source.error "identityref must reference 'base' identity"

      (value) ->
        match = source.resolve 'identity', value
        unless (match? and params.base is match.base)
          throw source.error "[#{@opts.type}] identityref is invalid for '#{value}'"
        # TODO - need to figure out how to return namespace value...
        value

instance-identifier: !yang/typedef
  construct: !coffee/function |
    (params={}, source) ->

leafref: !yang/typedef
  construct: !coffee/function |
    (params={}, source) ->
      unless typeof params.path is 'string'
        throw source.error "leafref must contain 'path' statement"

      (value) ->
        self = this
        value: value
        path: params.path
        validate: -> true
        get: ->
          ref = source.locate self, @path
          match = switch
            when ref instanceof Array then @value in ref
            else @value is ref
          if match is true
            @value
          else
            'error-tag': 'data-missing'
            'error-app-tag': 'instance-required'
            'error-path': @path

number: !yang/typedef
  construct: !coffee/function |
    (value) ->
      if Number.isNaN (Number value)
        throw new Error "#{@arg} expects '#{value}' to convert into a number"
      if @range?
        ranges = @range.arg.split '|'
        ranges = ranges.map (e) ->
          [ min, max ] = e.split '..'
          if max is 'max'
            console.warn "max keyword on range not yet supported"
          min = (Number) min
          max = (Number) max
          (v) -> (not min? or v >= min) and (not max? or v <= max)
      value = Number value
      unless (not ranges? or ranges.some (test) -> test? value)
        throw new Error "#{@arg} range violation for '#{value}' on #{@range.arg}"
      value

string: !yang/typedef
  construct: !coffee/function |
    (value) ->
      patterns = @pattern?.map (x) -> x.arg
      if @length?
        ranges = @length.arg.split '|'
        ranges = ranges.map (e) ->
          [ min, max ] = e.split '..'
          min = (Number) min
          max = switch
            when max is 'max' then null
            else (Number) max
          (v) -> (not min? or v.length >= min) and (not max? or v.length <= max)

      value = String value
      unless (not ranges? or ranges.some (test) -> test? value)
        throw new Error "#{@arg} length violation for '#{value}' on #{@length.arg}"
      unless (not patterns? or patterns.every (regex) -> regex.test value)
        throw new Error "#{@arg} pattern violation for '#{value}'"
      value

union: !yang/typedef
  construct: !coffee/function  |
    (params={}, source, callee) ->
      types = (for key, value of params.type
        result = {}
        callee.call source, key, value, null, result
        result.type
      ).filter (e) -> e?
      (value) ->
        for type in types
          try return type value
          catch then continue
        throw new Error "[#{@opts.type}] unable to find matching type for '#{value}' within: #{types}"
