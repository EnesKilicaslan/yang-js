# Model - instance of schema-driven data

The `Model` class is where the [Yang](./yang.litcoffee) schema
expression and the data object come together to provide the *adaptive*
and *event-driven* data interactions.

It is typically not instantiated directly, but is generated as a
result of [Yang::eval](./yang.litcoffee#eval-data-opts).

```javascript
var schema = Yang.parse('container foo { leaf a { type uint8; } }');
var model = schema.eval({ foo: { a: 7 } });
// model is { foo: [Getter/Setter] }
// model.foo is { a: [Getter/Setter] }
// model.foo.a is 7
```

The generated `Model` is a hierarchical composition of
[Property](./property.litcoffee) instances. The instance itself uses
`Object.preventExtensions` to ensure no additional properties that are
not known to itself can be added.

## Class Model

    Emitter    = require './emitter'
    XPath      = require './xpath'
    Expression = require './expression'

    class Model extends Emitter

      constructor: (schema, props={}) ->
        unless schema instanceof Expression
          throw new Error "cannot create a new Model without schema Expression"

        super
        unless schema.kind is 'module'
          schema = (new Expression 'module').extends schema

        prop.join this for k, prop of props when prop.schema in schema.nodes

        Object.defineProperties this,
          '_id': value: schema.tag ? Object.keys(this).join('+')
          '__':  value: { name: schema.tag, schema: schema }
        Object.preventExtensions this

## Instance-level methods

### on (event)

The `Model` instance is an `EventEmitter` and you can attach various
event listeners to handle events generated by the `Model`:

event | arguments | description
--- | --- | ---
update | (prop, prev) | fired when an update takes place within the data tree
change | (elems...) | fired when the schema is modified
create | (items...) | fired when one or more `list` element is added
delete | (items...) | fired when one or more `list` element is deleted

It also accepts optional XPATH expressions which will *filter* for
granular event subscription to specified events from only the elements
of interest.

The event listeners to the `Model` can handle any customized behavior
such as saving to database, updating read-only state, scheduling
background tasks, etc.

      on: (event, xpath..., callback) ->
        unless callback instanceof Function
          throw new Error "must supply callback function to listen for events"
        xpath = xpath.map (x) -> XPath.parse x
        @on event, (prop, args...) ->
          if not xpath.length or (xpath.some (x) -> x.compare prop.path, filter: false)
            callback.apply { model: this, ts: Date.now() }, [prop].concat args

Please refer to [Model Events](../TUTORIAL.md#model-events) section of
the [Getting Started Guide](../TUTORIAL.md) for usage examples.

### in (uri)

A helper routine to parse RESTful URI and returns one or more matching
Property instances.

TODO: make URI parsing to be XPATH configurable (xpath://?)

      in: (uri='') ->
        keys = uri.split('/').filter (x) -> x? and !!x
        unless keys.length > 0
          props = (v for k, v of @__props__)
          return switch
            when not props.length then null
            when props.length > 1 then props
            else props[0]
        
        key = keys.shift()
        expr = @__.schema
        expr = switch
          when expr.tag is key then expr
          else expr.locate key
        str = "/#{key}"
        while (key = keys.shift()) and expr?
          unless expr.kind in [ 'list', 'container' ]
            expr = undefined
            break
          if expr.kind is 'list' and not (expr.locate key)?
            str += "[key() = '#{key}']"
            key = keys.shift()
            unless key?
              li = true
              break 
          expr = expr.locate key
          str += "/#{expr.datakey}" if expr?
        return null if keys.length or not expr?

        props = XPath.parse(str).apply(this).props
        return switch
          when not props.length then null
          when props.length > 1 then props
          else props[0]

## Export Model Class

    module.exports = Model
